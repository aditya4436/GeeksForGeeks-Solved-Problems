// Time Complexity:- O(nlogn) + O(2n)
// Space Complexity:- O(n)
class Solution:
	def mergeOverlap(self, arr):
	    arr.sort()
		n = len(arr)
		ans = []
		
		for i in range(n):
		    start, end = arr[i]
		    if ans and end <= ans[-1][1]:
		        continue
		    
		    for j in range(i + 1, n):
		        if arr[j][0] <= end:
		            end = max(arr[j][1], end)
	            else:
	                break
            
            ans.append([start, end])
            
        return ans

// Time ComplexityL:- O(nlogn) + O(n)
//Space Complexity:- O(n)
class Solution:
	def mergeOverlap(self, arr):
	    arr.sort()
		n = len(arr)
		ans = []
		
		for i in range(n):
		    if not ans or arr[i][0] > ans[-1][1]:
		        ans.append(arr[i])
	        else:
	            ans[-1][1] = max(ans[-1][1], arr[i][1])
        
        return ans
